---
title: "REPLACE ME"
output:
    html_document:
    df_print: paged
theme: sandstone
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
source(here::here("code/lib.R"))
theme_set(theme_bw())

suppressWarnings(library(tidyverse))
library(GGally)
library(ggfortify)
library(broom)
require(ISLR)
library(modelr) # devtools::install_github("hadley/modelr")

```

```{r read}
atividade = read_projectdata()
```

Qual a relação entre as características da atuação do parlamentar e o engajamento total que ele obtém no twitter? 

```{r}
atividade %>% 
  filter(!is.na(twitter)) %>% 
  filter(!is.na(seguidores))
```

# Uma regressão linear simples 

### Modelo da relação entre gasto com TV e vendas. 

Linear direto com os dados.

```{r}
seguidores.model = lm(seguidores ~ engaj_total, data = atividade)
tidy(seguidores.model)
adv_augmented = atividade %>% 
  add_predictions(seguidores.model) %>% 
  add_residuals(seguidores.model)
# Modelo x dados
adv_augmented %>% 
  ggplot(aes(x = seguidores)) + 
  geom_line(aes(y = pred), size = 2, colour = "blue") + 
  geom_point(aes(y = engaj_total))
# Resíduos x dados
adv_augmented %>% 
  ggplot(aes(x = seguidores)) + 
  geom_point(aes(y = resid), size = 2) +
  geom_ref_line(h = 0, colour = "grey80")
tidy(seguidores.model, conf.int = TRUE)
glance(seguidores.model, conf.int = TRUE)
```

A função linear não se adequa lá muito bem. Outras que poderíamos usar:

```{r}
d = tibble(x = 1:100)
d %>% 
  ggplot(aes(x = x)) + 
  geom_line(aes(y = log2(x)), color = "blue") + 
  geom_line(aes(y = sqrt(x)), color = "red") 
```

## Testando Transformações

`y ~ log(x)` ainda não parece linear, e tem heteroscedasticidade.

```{r}
atividade %>% 
  mutate(seguidores = log10(seguidores)) %>% 
  ggplot(aes(x = seguidores)) + 
  geom_point(aes(y = engaj_total)) + 
  ggtitle("y ~ log(x)")
```

`log(y) ~ log(x)` faz a relação se parecer muito mais com uma relação linear.

```{r}
atividade %>% 
  mutate(engaj_total = log10(engaj_total), 
         seguidores = log10(seguidores)) %>% 
  ggplot(aes(x = seguidores)) + 
  geom_point(aes(y = engaj_total)) + 
  ggtitle("log(y) ~ log(x)")
```

## Usando a relação entre as variáveis transformadas para ajustar um modelo linear

```{r}
advertising  = advertising %>% 
  mutate(TV2 = log2(TV), 
         Sales2 = log2(Sales))
tv.model = lm(Sales2 ~ TV2, data = advertising)
```

Para visualizar o modelo, usarmeos um data frame com os dados originais e com as estimativas do modelo e resíduos para os valores nos dados. 

```{r}
adv_augmented = advertising %>% 
  add_predictions(tv.model) %>% 
  add_residuals(tv.model)
```

Visualizando. Primeiro `log(Sales) ~ log(TV)`:

```{r}
# Modelo x dados
adv_augmented %>% 
  ggplot(aes(x = TV2)) + 
  geom_line(aes(y = pred), size = 2, colour = "blue") + 
  geom_point(aes(y = Sales2))
# Resíduos x dados
adv_augmented %>% 
  ggplot(aes(x = TV2)) + 
  geom_point(aes(y = resid), size = 2) +
  geom_ref_line(h = 0, colour = "grey80")
```

E como é esse modelo?

```{r}
tidy(tv.model, conf.int = TRUE)
glance(tv.model, conf.int = TRUE)
```

O modelo é $log_2(Sales) = 1.3 + 0.35*log_2(TV)$. Isso é equivalente a $2^{log_2(Sales)} = 2^{1.3 + 0.35*log_2(TV)}$ que equivale a $Sales = 2^{1.3}*TV^{0.35}$. Testando: 
```{r}
## estimativa do modelo
p = predict(tv.model, 
            data.frame(TV2 = log2(100)))
## Como o modelo estima log2(Sales), para ver Sales, fazemos o inverso de log2:
paste("Estimativa do modelo:", 2**p)

## estimativa na mão
paste("Estimativa da fórmula:", (2**1.3059)*100**.355)
```
Uma boa ideia é visualizar `Sales` em função de `TV`, ambas sem transformação. Repare que os ranges de TV e do eixo y estão ambos como nas variáveis originais. Estamos visualizando `2**pred` no eixo vertical para compensar o fato de que `pred`, vinda do modelo, é um valor estimado para `log2(Sales)`.
```{r}
adv_augmented %>% 
  ggplot(aes(x = TV)) + 
  geom_line(aes(y = 2**(pred)), size = 2, colour = "blue") + 
  geom_point(aes(y = Sales)) + 
  ylab("Sales")
```